{"version":3,"file":"gpc.bundle.js","mappings":";;;;;;;;;;;AAAa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;AC9CF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,YAAY;AACZ,kBAAkB,mBAAO,CAAC,oCAAW;AACrC,mBAAmB,mBAAO,CAAC,sCAAY;AACvC,sBAAsB,mBAAO,CAAC,4CAAe;AAC7C,iBAAiB,mBAAO,CAAC,kCAAU;AACnC,iBAAiB,mBAAO,CAAC,kCAAU;AACnC,eAAe,mBAAO,CAAC,8BAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,iBAAiB;AACrC;AACA;AACA,uDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA,wBAAwB,iBAAiB;AACzC;AACA;AACA,2DAA2D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD,eAAe;AACpE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,mBAAmB;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB,yBAAyB;AACzB;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,KAAK;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA,wBAAwB,aAAa;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0CAA0C,oBAAoB;AAC9D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,OAAO;AACzB,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD,oBAAoB,aAAa;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,OAAO;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;;;;;;;;;;;ACnhBC;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,gBAAgB,GAAG,oBAAoB,GAAG,wBAAwB;AACrF,eAAe,mBAAO,CAAC,8BAAQ;AAC/B;AACA;AACA,UAAU,eAAe;AACzB;AACA,oBAAoB,OAAO;AAC3B,gBAAgB,OAAO;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B,OAAO;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB,UAAU,eAAe;AACzB;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;;;ACtHH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe,GAAG,gBAAgB;AAClC,eAAe,mBAAO,CAAC,8BAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kCAAkC,gBAAgB,KAAK;AACxD;AACA;AACA,gBAAgB;AAChB;AACA;AACA,oBAAoB,OAAO,OAAO;AAClC,6BAA6B;AAC7B,oCAAoC;AACpC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B;AACA;AACA;AACA,eAAe;AACf,qCAAqC;AACrC;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;ACrDF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB;AACnB,mBAAmB,mBAAO,CAAC,sCAAY;AACvC,eAAe,mBAAO,CAAC,8BAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,eAAe;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;;;;;ACrHN;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB;AAChB;AACA;AACA,qBAAqB,kBAAkB;AACvC,qBAAqB,kBAAkB;AACvC,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;AACvB,uBAAuB;AACvB,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,0BAA0B;AAC1B,+BAA+B;AAC/B,wBAAwB;AACxB,uBAAuB;AACvB,wBAAwB;AACxB,wBAAwB;AACxB,sBAAsB;AACtB;AACA;AACA,gBAAgB;;;;;;;;;;;ACvBH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB;AACjB,mBAAmB,mBAAO,CAAC,sCAAY;AACvC,eAAe,mBAAO,CAAC,8BAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;AC3CJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,eAAe,mBAAO,CAAC,8BAAQ;AAC/B;AACA,YAAY,QAAQ;AACpB;AACA;AACA;AACA;AACA,eAAe;;;;;;;;;;;ACVF;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,gBAAgB,GAAG,gBAAgB,GAAG,eAAe;AACrD,sBAAsB,mBAAO,CAAC,4CAAe;AAC7C,oBAAoB,mBAAO,CAAC,wCAAa;AACzC,mBAAmB,mBAAO,CAAC,sCAAY;AACvC,eAAe,mBAAO,CAAC,8BAAQ;AAC/B;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,cAAc;AAC1C;AACA,4BAA4B,OAAO;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB;;;;;;;;;;;AClDH;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,sBAAsB,GAAG,mBAAmB;AAC5C,uBAAuB,mBAAO,CAAC,8CAAgB;AAC/C,eAAe,mBAAO,CAAC,8BAAQ;AAC/B;AACA;AACA,4BAA4B;AAC5B,2BAA2B;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,eAAe;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4CAA4C,kBAAkB;AAC9D;AACA;AACA;AACA;AACA;AACA,+CAA+C,cAAc;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,cAAc;AAC9D,6DAA6D;AAC7D,kDAAkD,QAAQ;AAC1D;AACA;AACA;AACA;AACA;AACA,gCAAgC,oBAAoB;AACpD;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,sBAAsB;;;;;;;;;;;ACnHT;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,2BAA2B;AAC3B;AACA;AACA;AACA,0BAA0B;AAC1B,0BAA0B;AAC1B,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,2BAA2B;;;;;;;;;;;ACtDd;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,iBAAiB,GAAG,mBAAmB,GAAG,cAAc;AACxD,eAAe,mBAAO,CAAC,8BAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAiC,eAAe;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;;;;;;;;;;;ACpEJ;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,kBAAkB,GAAG,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,OAAO;AAC3B;AACA,iFAAiF;AACjF;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;;;;;;;;;;;ACpCL;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,mBAAmB,GAAG,iBAAiB,GAAG,cAAc,GAAG,qBAAqB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,kBAAkB,GAAG,UAAU,GAAG,qBAAqB,GAAG,uBAAuB,GAAG,sBAAsB,GAAG,YAAY,GAAG,YAAY,GAAG,aAAa,GAAG,YAAY,GAAG,eAAe,GAAG,mBAAmB,GAAG,kBAAkB,GAAG,gBAAgB;AACpX;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA,CAAC,wCAAwC,mBAAmB,KAAK;AACjE,eAAe;AACf,YAAY;AACZ,aAAa;AACb,YAAY;AACZ,YAAY;AACZ,sBAAsB;AACtB,uBAAuB;AACvB;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,4CAA4C,qBAAqB,KAAK;AACvE;AACA;AACA;AACA,UAAU;AACV;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,sCAAsC,kBAAkB,KAAK;AAC9D;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA,mBAAmB;AACnB,mBAAmB;AACnB,mBAAmB;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,8BAA8B,cAAc,KAAK;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,UAAU,eAAe;AACzB,oBAAoB,OAAO;AAC3B,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB;;;;;;;UCzGnB;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;;;;;;ACtBa;AACb,8CAA6C,EAAE,aAAa,EAAC;AAC7D,eAAe;AACf,eAAe,mBAAO,CAAC,8BAAQ;AAC/B,uBAAuB,mBAAO,CAAC,8CAAgB;AAC/C,mBAAmB,mBAAO,CAAC,sCAAY;AACvC,eAAe,mBAAO,CAAC,8BAAQ;AAC/B,eAAe,mBAAO,CAAC,8BAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,6BAA6B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wDAAwD,6BAA6B;AACrF;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;AACA;AACA,eAAe;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,eAAe;AAC/B,gBAAgB,eAAe;AAC/B;AACA;AACA;AACA;AACA,0BAA0B,cAAc;AACxC,oBAAoB,eAAe;AACnC;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sCAAsC;AACxD,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,WAAW;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA4B,yBAAyB;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,wBAAwB;AAChD;AACA;AACA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://GPC/./dist/AetTree.js","webpack://GPC/./dist/Clip.js","webpack://GPC/./dist/Conditioning.js","webpack://GPC/./dist/Contains.js","webpack://GPC/./dist/CountorPass.js","webpack://GPC/./dist/EdgeNode.js","webpack://GPC/./dist/EdgeTable.js","webpack://GPC/./dist/IPolygon.js","webpack://GPC/./dist/LmtTable.js","webpack://GPC/./dist/PolygonNode.js","webpack://GPC/./dist/SBTree.js","webpack://GPC/./dist/StNode.js","webpack://GPC/./dist/hull.js","webpack://GPC/./dist/util.js","webpack://GPC/webpack/bootstrap","webpack://GPC/./dist/gpc.js"],"sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AetTree = void 0;\nclass AetTree {\n    constructor() {\n        this.top = null;\n    }\n    addEdge(edge) {\n        if (this.top === null) {\n            /* Append edge onto the tail end of the AET */\n            this.top = edge;\n            edge.prev = null;\n            edge.next = null;\n            return;\n        }\n        let prevEdge = null;\n        let currentEdge = this.top;\n        while (true) {\n            /* Do primary sort on the xb field, and secondary sort on the dx field. */\n            if (edge.xb < currentEdge.xb || (edge.xb === currentEdge.xb && edge.dx < currentEdge.dx)) {\n                /* Insert edge here (before the AET edge) */\n                edge.prev = prevEdge;\n                edge.next = currentEdge;\n                currentEdge.prev = edge;\n                if (prevEdge === null) {\n                    this.top = edge;\n                }\n                else {\n                    prevEdge.next = edge;\n                }\n                return;\n            }\n            /* Head further into the AET */\n            prevEdge = currentEdge;\n            if (currentEdge.next === null) {\n                currentEdge.next = edge;\n                edge.prev = currentEdge;\n                edge.next = null;\n                return;\n            }\n            else {\n                currentEdge = currentEdge.next;\n            }\n        }\n    }\n}\nexports.AetTree = AetTree;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.clip = void 0;\nconst AetTree_1 = require(\"./AetTree\");\nconst LmtTable_1 = require(\"./LmtTable\");\nconst PolygonNode_1 = require(\"./PolygonNode\");\nconst SBTree_1 = require(\"./SBTree\");\nconst StNode_1 = require(\"./StNode\");\nconst util_1 = require(\"./util\");\nfunction miniMaxTest(subject, clipper, op) {\n    const sBBoxes = subject.getInnerPolies().map((ip) => ip.bounds);\n    const cBBoxes = clipper.getInnerPolies().map((ip) => ip.bounds);\n    /* Check all subject contour bounding boxes against clip boxes */\n    const oTable = cBBoxes.map((c) => sBBoxes.map((s) => !((s.maxx < c.minx) || (s.minx > c.maxx)) &&\n        !((s.maxy < c.miny) || (s.miny > c.maxy))));\n    /* For each clip contour, search for any subject contour overlaps */\n    const clipNumPoly = cBBoxes.length;\n    for (let c = 0; c < clipNumPoly; c++) {\n        const overlap = oTable[c].every((s) => s);\n        if (!overlap) {\n            clipper[util_1.setContributing](c, false); // Flag non contributing status\n        }\n    }\n    if (op === util_1.OperationType.INT) {\n        /* For each subject contour, search for any clip contour overlaps */\n        const subjNumPoly = sBBoxes.length;\n        for (let s = 0; s < subjNumPoly; s++) {\n            const overlap = oTable.every((c) => c[s]);\n            if (!overlap) {\n                subject[util_1.setContributing](s, false); // Flag non contributing status\n            }\n        }\n    }\n}\nfunction clip(op, subject, clipper, Simple, Compound) {\n    const sEmpty = subject.isEmpty;\n    const cEmpty = clipper.isEmpty;\n    /* Test for trivial NULL result cases */\n    if ((cEmpty && op === util_1.OperationType.INT) ||\n        (sEmpty && (cEmpty || op === util_1.OperationType.INT || op === util_1.OperationType.DIF))) {\n        return new Simple([], false);\n    }\n    /* Identify potentialy contributing contours */\n    if ((op === util_1.OperationType.INT || op === util_1.OperationType.DIF) && !(sEmpty || cEmpty)) {\n        miniMaxTest(subject, clipper, op);\n    }\n    /* Build LMT */\n    const lmtTable = new LmtTable_1.LmtTable();\n    const sbte = new SBTree_1.ScanBeamTreeEntries();\n    if (!sEmpty) {\n        LmtTable_1.buildLmt(lmtTable, sbte, subject, util_1.SUBJ, op);\n    }\n    if (!cEmpty) {\n        LmtTable_1.buildLmt(lmtTable, sbte, clipper, util_1.CLIP, op);\n    }\n    /* Return a NULL result if no contours contribute */\n    if (lmtTable.top === null) {\n        return new Simple([], false);\n    }\n    const parity = {\n        /* Invert clip polygon for difference operation */\n        clip: op === util_1.OperationType.DIF ? util_1.RIGHT : util_1.LEFT,\n        subj: util_1.LEFT,\n    };\n    /* Build scanbeam table from scanbeam tree */\n    const sbt = sbte.buildSBT();\n    /* Used to create resulting Polygon */\n    const outPoly = new PolygonNode_1.TopPolygonNode(Simple, Compound);\n    const aet = new AetTree_1.AetTree();\n    let scanbeam = 0;\n    let localMin = lmtTable.top;\n    /* Process each scanbeam */\n    while (scanbeam < sbt.length) {\n        /* Set yb and yt to the bottom and top of the scanbeam */\n        const yb = sbt[scanbeam++];\n        let yt = 0;\n        let dy = 0;\n        if (scanbeam < sbt.length) {\n            yt = sbt[scanbeam];\n            dy = yt - yb;\n        }\n        /* === SCANBEAM BOUNDARY PROCESSING ================================ */\n        /* If LMT node corresponding to yb exists */\n        if (localMin !== null) {\n            if (localMin.y === yb) {\n                /* Add edges starting at this local minimum to the AET */\n                for (let edge = localMin.firstBound; edge !== null; edge = edge.nextBound) {\n                    aet.addEdge(edge);\n                }\n                localMin = localMin.next;\n            }\n        }\n        if (aet.top === null)\n            throw new Error(\"Encountered Unexpected Null Edge\");\n        /* Create bundles within AET */\n        let e0 = aet.top;\n        let e1 = aet.top;\n        /* Set up bundle fields of first edge */\n        aet.top.bundle.above[aet.top.type] = (aet.top.top.y !== yb) ? 1 : 0;\n        aet.top.bundle.above[1 - aet.top.type] = 0;\n        aet.top.bstate.above = util_1.BundleState.UNBUNDLED;\n        for (let nextEdge = aet.top.next; nextEdge !== null; nextEdge = nextEdge.next) {\n            const nextType = nextEdge.type;\n            const nextTypeOpposite = 1 - nextType;\n            /* Set up bundle fields of next edge */\n            nextEdge.bundle.above[nextType] = (nextEdge.top.y !== yb) ? 1 : 0;\n            nextEdge.bundle.above[nextTypeOpposite] = 0;\n            nextEdge.bstate.above = util_1.BundleState.UNBUNDLED;\n            /* Bundle edges above the scanbeam boundary if they coincide */\n            if (nextEdge.bundle.above[nextType] === 1) {\n                if (util_1.EQ(e0.xb, nextEdge.xb) && util_1.EQ(e0.dx, nextEdge.dx) && (e0.top.y !== yb)) {\n                    nextEdge.bundle.above[nextType] ^= e0.bundle.above[nextType];\n                    nextEdge.bundle.above[nextTypeOpposite] = e0.bundle.above[nextTypeOpposite];\n                    nextEdge.bstate.above = util_1.BundleState.BUNDLE_HEAD;\n                    e0.bundle.above[util_1.CLIP] = 0;\n                    e0.bundle.above[util_1.SUBJ] = 0;\n                    e0.bstate.above = util_1.BundleState.BUNDLE_TAIL;\n                }\n                e0 = nextEdge;\n            }\n        }\n        const horiz = { clip: util_1.HState.NH, subj: util_1.HState.NH };\n        const exists = { clip: 0, subj: 0 };\n        /* Set dummy previous x value */\n        let px = -Number.MAX_VALUE;\n        let cf = null;\n        /* Process each edge at this scanbeam boundary */\n        for (let edge = aet.top; edge !== null; edge = edge.next) {\n            exists.clip = edge.bundle.above[util_1.CLIP] + (edge.bundle.below[util_1.CLIP] << 1);\n            exists.subj = edge.bundle.above[util_1.SUBJ] + (edge.bundle.below[util_1.SUBJ] << 1);\n            if ((exists.clip | exists.subj) === 0) {\n                continue;\n            }\n            /* Set bundle side */\n            edge.bside.clip = parity.clip;\n            edge.bside.subj = parity.subj;\n            let contributing = false;\n            let br = 0;\n            let bl = 0;\n            let tr = 0;\n            let tl = 0;\n            /* Determine contributing status and quadrant occupancies */\n            if ((op === util_1.OperationType.DIF) || (op === util_1.OperationType.INT)) {\n                contributing = ((exists.clip !== 0) && ((parity.subj !== 0) || (horiz.subj !== 0))) ||\n                    ((exists.subj !== 0) && ((parity.clip !== 0) || (horiz.clip !== 0))) ||\n                    ((exists.clip !== 0) && (exists.subj !== 0) && (parity.clip === parity.subj));\n                br = parity.clip & parity.subj;\n                bl = (parity.clip ^ edge.bundle.above[util_1.CLIP]) & (parity.subj ^ edge.bundle.above[util_1.SUBJ]);\n                tr = (parity.clip ^ (horiz.clip !== util_1.HState.NH ? 1 : 0)) & (parity.subj ^ (horiz.subj !== util_1.HState.NH ? 1 : 0));\n                tl = (parity.clip ^ (horiz.clip !== util_1.HState.NH ? 1 : 0) ^ edge.bundle.below[util_1.CLIP]) &\n                    (parity.subj ^ (horiz.subj !== util_1.HState.NH ? 1 : 0) ^ edge.bundle.below[util_1.SUBJ]);\n            }\n            else if (op === util_1.OperationType.XOR) {\n                contributing = (exists.clip !== 0) || (exists.subj !== 0);\n                br = parity.clip ^ parity.subj;\n                bl = (parity.clip ^ edge.bundle.above[util_1.CLIP]) ^ (parity.subj ^ edge.bundle.above[util_1.SUBJ]);\n                tr = parity.clip ^ (horiz.clip !== util_1.HState.NH ? 1 : 0) ^ parity.subj ^ (horiz.subj !== util_1.HState.NH ? 1 : 0);\n                tl = parity.clip ^ (horiz.clip !== util_1.HState.NH ? 1 : 0) ^ edge.bundle.below[util_1.CLIP]\n                    ^ parity.subj ^ (horiz.subj !== util_1.HState.NH ? 1 : 0) ^ edge.bundle.below[util_1.SUBJ];\n            }\n            else if (op === util_1.OperationType.ADD) {\n                contributing = ((exists.clip !== 0) && (!(parity.subj !== 0) || (horiz.subj !== 0))) ||\n                    ((exists.subj !== 0) && (!(parity.clip !== 0) || (horiz.clip !== 0))) ||\n                    ((exists.clip !== 0) && (exists.subj !== 0) && (parity.clip === parity.subj));\n                br = parity.clip | parity.subj;\n                bl = (parity.clip ^ edge.bundle.above[util_1.CLIP]) | (parity.subj ^ edge.bundle.above[util_1.SUBJ]);\n                tr = (parity.clip ^ (horiz.clip !== util_1.HState.NH ? 1 : 0)) | (parity.subj ^ ((horiz.subj !== util_1.HState.NH) ? 1 : 0));\n                tl = (parity.clip ^ (horiz.clip !== util_1.HState.NH ? 1 : 0) ^ edge.bundle.below[util_1.CLIP]) |\n                    (parity.subj ^ (horiz.subj !== util_1.HState.NH ? 1 : 0) ^ edge.bundle.below[util_1.SUBJ]);\n            }\n            /* Update parity */\n            parity.clip ^= edge.bundle.above[util_1.CLIP];\n            parity.subj ^= edge.bundle.above[util_1.SUBJ];\n            /* Update horizontal state */\n            if (exists.clip !== 0) {\n                horiz.clip = util_1.HState.nextState[horiz.clip][((exists.clip - 1) << 1) + parity.clip];\n            }\n            if (exists.subj !== 0) {\n                horiz.subj = util_1.HState.nextState[horiz.subj][((exists.subj - 1) << 1) + parity.subj];\n            }\n            if (!contributing) {\n                continue;\n            }\n            const { xb } = edge;\n            switch (util_1.getVertexType(tr, tl, br, bl)) {\n                case util_1.VertexType.EMN:\n                case util_1.VertexType.IMN:\n                    cf = outPoly.addLocalMin(xb, yb);\n                    px = xb;\n                    edge.outp.above = cf;\n                    break;\n                case util_1.VertexType.ERI:\n                    if (cf === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (xb !== px) {\n                        cf.addRight(xb, yb);\n                        px = xb;\n                    }\n                    edge.outp.above = cf;\n                    cf = null;\n                    break;\n                case util_1.VertexType.ELI:\n                    cf = edge.outp.below;\n                    if (cf === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    cf.addLeft(xb, yb);\n                    px = xb;\n                    break;\n                case util_1.VertexType.EMX:\n                    if (cf === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (edge.outp.below === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (xb !== px) {\n                        cf.addLeft(xb, yb);\n                        px = xb;\n                    }\n                    outPoly.mergeRight(cf, edge.outp.below);\n                    cf = null;\n                    break;\n                case util_1.VertexType.ILI:\n                    if (cf === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (xb !== px) {\n                        cf.addLeft(xb, yb);\n                        px = xb;\n                    }\n                    edge.outp.above = cf;\n                    cf = null;\n                    break;\n                case util_1.VertexType.IRI:\n                    cf = edge.outp.below;\n                    if (cf === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    cf.addRight(xb, yb);\n                    px = xb;\n                    edge.outp.below = null;\n                    break;\n                case util_1.VertexType.IMX:\n                    if (cf === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (edge.outp.below === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (xb !== px) {\n                        cf.addRight(xb, yb);\n                        px = xb;\n                    }\n                    outPoly.mergeLeft(cf, edge.outp.below);\n                    cf = null;\n                    edge.outp.below = null;\n                    break;\n                case util_1.VertexType.IMM:\n                    if (cf === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (edge.outp.below === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (xb !== px) {\n                        cf.addRight(xb, yb);\n                        px = xb;\n                    }\n                    outPoly.mergeLeft(cf, edge.outp.below);\n                    edge.outp.below = null;\n                    cf = outPoly.addLocalMin(xb, yb);\n                    edge.outp.above = cf;\n                    break;\n                case util_1.VertexType.EMM:\n                    if (cf === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (edge.outp.below === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (xb !== px) {\n                        cf.addLeft(xb, yb);\n                        px = xb;\n                    }\n                    outPoly.mergeRight(cf, edge.outp.below);\n                    edge.outp.below = null;\n                    cf = outPoly.addLocalMin(xb, yb);\n                    edge.outp.above = cf;\n                    break;\n                case util_1.VertexType.LED:\n                    if (edge.outp.below === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (edge.bot.y === yb) {\n                        edge.outp.below.addLeft(xb, yb);\n                    }\n                    edge.outp.above = edge.outp.below;\n                    px = xb;\n                    break;\n                case util_1.VertexType.RED:\n                    if (edge.outp.below === null)\n                        throw new Error(\"Unexpected Null Polygon\");\n                    if (edge.bot.y === yb) {\n                        edge.outp.below.addRight(xb, yb);\n                    }\n                    edge.outp.above = edge.outp.below;\n                    px = xb;\n                    break;\n                default:\n            }\n        }\n        /* Delete terminating edges from the AET, otherwise compute xt */\n        for (let edge = aet.top; edge !== null; edge = edge.next) {\n            if (edge.top.y === yb) {\n                const { prev, next } = edge;\n                if (prev === null) {\n                    aet.top = next;\n                }\n                else {\n                    prev.next = next;\n                }\n                if (next !== null) {\n                    next.prev = prev;\n                }\n                /* Copy bundle head state to the adjacent tail edge if required */\n                if ((edge.bstate.below === util_1.BundleState.BUNDLE_HEAD) && (prev !== null)) {\n                    if (prev.bstate.below === util_1.BundleState.BUNDLE_TAIL) {\n                        prev.outp.below = edge.outp.below;\n                        prev.bstate.below = util_1.BundleState.UNBUNDLED;\n                        if (prev.prev !== null) {\n                            if (prev.prev.bstate.below === util_1.BundleState.BUNDLE_TAIL) {\n                                prev.bstate.below = util_1.BundleState.BUNDLE_HEAD;\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                edge.xt = edge.top.y === yt ?\n                    edge.top.x : (edge.bot.x + edge.dx * (yt - edge.bot.y));\n            }\n        }\n        if (scanbeam >= sbte.sbtEntries) {\n            continue;\n        }\n        /* === SCANBEAM INTERIOR PROCESSING ============================== */\n        /* Build intersection table for the current scanbeam */\n        const itTable = new StNode_1.ItNodeTable();\n        itTable.buildIntersectionTable(aet, dy);\n        /* Process each node in the intersection table */\n        for (let intersect = itTable.top; intersect !== null; intersect = intersect.next) {\n            [e0, e1] = intersect.ie;\n            /* Only generate output for contributing intersections */\n            if (((e0.bundle.above[util_1.CLIP] !== 0) || (e0.bundle.above[util_1.SUBJ] !== 0)) &&\n                ((e1.bundle.above[util_1.CLIP] !== 0) || (e1.bundle.above[util_1.SUBJ] !== 0))) {\n                const p = e0.outp.above;\n                const q = e1.outp.above;\n                const ix = intersect.point.x;\n                const iy = intersect.point.y + yb;\n                const inClip = (((e0.bundle.above[util_1.CLIP] !== 0) && (e0.bside.clip === 0)) ||\n                    ((e1.bundle.above[util_1.CLIP] !== 0) && (e1.bside.clip !== 0)) ||\n                    ((e0.bundle.above[util_1.CLIP] === 0) && (e1.bundle.above[util_1.CLIP] === 0) &&\n                        ((e0.bside.clip & e1.bside.clip) === 1))) ? 1 : 0;\n                const inSubj = (((e0.bundle.above[util_1.SUBJ] !== 0) && (e0.bside.subj === 0)) ||\n                    ((e1.bundle.above[util_1.SUBJ] !== 0) && (e1.bside.subj !== 0)) ||\n                    ((e0.bundle.above[util_1.SUBJ] === 0) && (e1.bundle.above[util_1.SUBJ] === 0) &&\n                        ((e0.bside.subj & e1.bside.subj) === 1))) ? 1 : 0;\n                let tr = 0;\n                let tl = 0;\n                let br = 0;\n                let bl = 0;\n                /* Determine quadrant occupancies */\n                if ((op === util_1.OperationType.DIF) || (op === util_1.OperationType.INT)) {\n                    tr = inClip & inSubj;\n                    tl = (inClip ^ e1.bundle.above[util_1.CLIP]) & (inSubj ^ e1.bundle.above[util_1.SUBJ]);\n                    br = (inClip ^ e0.bundle.above[util_1.CLIP]) & (inSubj ^ e0.bundle.above[util_1.SUBJ]);\n                    bl = (inClip ^ e1.bundle.above[util_1.CLIP] ^ e0.bundle.above[util_1.CLIP]) & (inSubj ^ e1.bundle.above[util_1.SUBJ] ^ e0.bundle.above[util_1.SUBJ]);\n                }\n                else if (op === util_1.OperationType.XOR) {\n                    tr = inClip ^ inSubj;\n                    tl = (inClip ^ e1.bundle.above[util_1.CLIP]) ^ (inSubj ^ e1.bundle.above[util_1.SUBJ]);\n                    br = (inClip ^ e0.bundle.above[util_1.CLIP]) ^ (inSubj ^ e0.bundle.above[util_1.SUBJ]);\n                    bl = (inClip ^ e1.bundle.above[util_1.CLIP] ^ e0.bundle.above[util_1.CLIP])\n                        ^ (inSubj ^ e1.bundle.above[util_1.SUBJ] ^ e0.bundle.above[util_1.SUBJ]);\n                }\n                else if (op === util_1.OperationType.ADD) {\n                    tr = inClip | inSubj;\n                    tl = (inClip ^ e1.bundle.above[util_1.CLIP]) | (inSubj ^ e1.bundle.above[util_1.SUBJ]);\n                    br = (inClip ^ e0.bundle.above[util_1.CLIP]) | (inSubj ^ e0.bundle.above[util_1.SUBJ]);\n                    bl = (inClip ^ e1.bundle.above[util_1.CLIP] ^ e0.bundle.above[util_1.CLIP]) | (inSubj ^ e1.bundle.above[util_1.SUBJ] ^ e0.bundle.above[util_1.SUBJ]);\n                }\n                switch (util_1.getVertexType(tr, tl, br, bl)) {\n                    case util_1.VertexType.EMN:\n                        e0.outp.above = outPoly.addLocalMin(ix, iy);\n                        e1.outp.above = e0.outp.above;\n                        break;\n                    case util_1.VertexType.ERI:\n                        if (p !== null) {\n                            p.addRight(ix, iy);\n                            e1.outp.above = p;\n                            e0.outp.above = null;\n                        }\n                        break;\n                    case util_1.VertexType.ELI:\n                        if (q !== null) {\n                            q.addLeft(ix, iy);\n                            e0.outp.above = q;\n                            e1.outp.above = null;\n                        }\n                        break;\n                    case util_1.VertexType.EMX:\n                        if ((p !== null) && (q !== null)) {\n                            p.addLeft(ix, iy);\n                            outPoly.mergeRight(p, q);\n                            e0.outp.above = null;\n                            e1.outp.above = null;\n                        }\n                        break;\n                    case util_1.VertexType.IMN:\n                        e0.outp.above = outPoly.addLocalMin(ix, iy);\n                        e1.outp.above = e0.outp.above;\n                        break;\n                    case util_1.VertexType.ILI:\n                        if (p !== null) {\n                            p.addLeft(ix, iy);\n                            e1.outp.above = p;\n                            e0.outp.above = null;\n                        }\n                        break;\n                    case util_1.VertexType.IRI:\n                        if (q !== null) {\n                            q.addRight(ix, iy);\n                            e0.outp.above = q;\n                            e1.outp.above = null;\n                        }\n                        break;\n                    case util_1.VertexType.IMX:\n                        if ((p !== null) && (q !== null)) {\n                            p.addRight(ix, iy);\n                            outPoly.mergeLeft(p, q);\n                            e0.outp.above = null;\n                            e1.outp.above = null;\n                        }\n                        break;\n                    case util_1.VertexType.IMM:\n                        if ((p !== null) && (q !== null)) {\n                            p.addRight(ix, iy);\n                            outPoly.mergeLeft(p, q);\n                            e0.outp.above = outPoly.addLocalMin(ix, iy);\n                            e1.outp.above = e0.outp.above;\n                        }\n                        break;\n                    case util_1.VertexType.EMM:\n                        if ((p !== null) && (q !== null)) {\n                            p.addLeft(ix, iy);\n                            outPoly.mergeRight(p, q);\n                            e0.outp.above = outPoly.addLocalMin(ix, iy);\n                            e1.outp.above = e0.outp.above;\n                        }\n                        break;\n                    default:\n                }\n            }\n            /* Swap bundle sides in response to edge crossing */\n            if (e0.bundle.above[util_1.CLIP] !== 0) {\n                e1.bside.clip = 1 - e1.bside.clip;\n            }\n            if (e1.bundle.above[util_1.CLIP] !== 0) {\n                e0.bside.clip = 1 - e0.bside.clip;\n            }\n            if (e0.bundle.above[util_1.SUBJ] !== 0) {\n                e1.bside.subj = 1 - e1.bside.subj;\n            }\n            if (e1.bundle.above[util_1.SUBJ] !== 0) {\n                e0.bside.subj = 1 - e0.bside.subj;\n            }\n            /* Swap e0 and e1 bundles in the AET */\n            let { prev } = e0;\n            const { next } = e1;\n            if (next !== null) {\n                next.prev = e0;\n            }\n            if (e0.bstate.above === util_1.BundleState.BUNDLE_HEAD) {\n                while (prev !== null && prev.bstate.above === util_1.BundleState.BUNDLE_TAIL) {\n                    prev = prev.prev;\n                }\n            }\n            if (aet.top === null)\n                throw new Error(\"Encountered Unexpected Null Edge\");\n            if (prev === null) {\n                aet.top.prev = e1;\n                e1.next = aet.top;\n                aet.top = e0.next;\n            }\n            else {\n                if (prev.next === null)\n                    throw new Error(\"Encountered Unexpected Null Edge\");\n                prev.next.prev = e1;\n                e1.next = prev.next;\n                prev.next = e0.next;\n            }\n            if (e0.next === null)\n                throw new Error(\"Encountered Unexpected Null Edge\");\n            e0.next.prev = prev;\n            e1.next.prev = e1;\n            e0.next = next;\n        }\n        /* Prepare for next scanbeam */\n        for (let edge = aet.top; edge !== null; edge = edge.next) {\n            const { next, succ } = edge;\n            if ((edge.top.y === yt) && (succ !== null)) {\n                /* Replace AET edge by its successor */\n                succ.outp.below = edge.outp.above;\n                succ.bstate.below = edge.bstate.above;\n                succ.bundle.below[util_1.CLIP] = edge.bundle.above[util_1.CLIP];\n                succ.bundle.below[util_1.SUBJ] = edge.bundle.above[util_1.SUBJ];\n                const { prev } = edge;\n                if (prev !== null) {\n                    prev.next = succ;\n                }\n                else {\n                    aet.top = succ;\n                }\n                if (next !== null) {\n                    next.prev = succ;\n                }\n                succ.prev = prev;\n                succ.next = next;\n            }\n            else {\n                /* Update this edge */\n                edge.outp.below = edge.outp.above;\n                edge.bstate.below = edge.bstate.above;\n                edge.bundle.below[util_1.CLIP] = edge.bundle.above[util_1.CLIP];\n                edge.bundle.below[util_1.SUBJ] = edge.bundle.above[util_1.SUBJ];\n                edge.xb = edge.xt;\n            }\n            edge.outp.above = null;\n        }\n    }\n    return outPoly.getResult();\n}\nexports.clip = clip;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSimple = exports.isConvex = exports.forceWinding = exports.rotateBottomLeft = void 0;\nconst util_1 = require(\"./util\");\nfunction findBottomLeft(points) {\n    const n = points.length;\n    let { x: px, y: py } = points[0];\n    let min = 0;\n    for (let i = 1; i < n; i++) {\n        const { x, y } = points[i];\n        if ((y < py) || ((py == y) && (x < px))) {\n            py = y;\n            px = x;\n            min = i;\n        }\n    }\n    return min;\n}\nfunction rotate(idx, points) {\n    const r = points.slice(idx);\n    for (let i = 0; i < idx; i++) {\n        r.push(points[i]);\n    }\n    return r;\n}\nfunction rotateBottomLeft(points) {\n    const idx = findBottomLeft(points);\n    if (idx === 0) {\n        return points;\n    }\n    return rotate(idx, points);\n}\nexports.rotateBottomLeft = rotateBottomLeft;\nfunction forceWinding(dir, points) {\n    const a = dir * util_1.polygonArea(points);\n    if (a >= 0) {\n        return dir * a;\n    }\n    const n = points.length;\n    for (let i = 1, j = n - 1; i < j; i++, j--) {\n        const t = points[i];\n        points[i] = points[j];\n        points[j] = t;\n    }\n    return dir * Math.abs(a);\n}\nexports.forceWinding = forceWinding;\nconst TWO_PI = 2 * Math.PI;\nfunction isConvex(points) {\n    const n = points.length;\n    if (n <= 3) {\n        return true;\n    }\n    let { x: ox, y: oy } = points[n - 2];\n    let { x: nx, y: ny } = points[n - 1];\n    let odir = 0;\n    let ndir = Math.atan2(ny - oy, nx - ox);\n    let angle_sum = 0;\n    let orientation = 0;\n    for (let i = 0; i < n; i++) {\n        const p = points[i];\n        ox = nx;\n        oy = ny;\n        odir = ndir;\n        nx = p.x;\n        ny = p.y;\n        ndir = Math.atan2(ny - oy, nx - ox);\n        let angle = ndir - odir;\n        // shift to the half-open interval (-Pi, Pi]\n        if (angle <= -Math.PI) {\n            angle += TWO_PI;\n        }\n        else if (angle > Math.PI) {\n            angle -= TWO_PI;\n        }\n        if (orientation === 0) {\n            orientation = angle;\n        }\n        else if (orientation * angle < 0) {\n            return false;\n        }\n        angle_sum += angle;\n    }\n    // Check that the total number of full turns is plus-or-minus 1\n    return Math.abs(Math.round(angle_sum / TWO_PI)) === 1;\n}\nexports.isConvex = isConvex;\nfunction isSimple(points) {\n    const n = points.length;\n    if (n <= 3) {\n        return true;\n    }\n    let { x: ox, y: oy } = points[n - 2];\n    let { x: nx, y: ny } = points[n - 1];\n    let odir = 0;\n    let ndir = Math.atan2(ny - oy, nx - ox);\n    let angle_sum = 0;\n    for (let i = 0; i < n; i++) {\n        const p = points[i];\n        ox = nx;\n        oy = ny;\n        odir = ndir;\n        nx = p.x;\n        ny = p.y;\n        ndir = Math.atan2(ny - oy, nx - ox);\n        let angle = ndir - odir;\n        // shift to the half-open interval (-Pi, Pi]\n        if (angle <= -Math.PI) {\n            angle += TWO_PI;\n        }\n        else if (angle > Math.PI) {\n            angle -= TWO_PI;\n        }\n        angle_sum += angle;\n    }\n    // Check that the total number of full turns is plus-or-minus 1\n    return Math.abs(Math.round(angle_sum / TWO_PI)) === 1;\n}\nexports.isSimple = isSimple;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.wn_poly = exports.Position = void 0;\nconst util_1 = require(\"./util\");\n// tests if a point is Left|On|Right of an infinite line.\n//    Input:  three points P0, P1, and P2\n//    Return: >0 for P2 left of the line through P0 and P1\n//            =0 for P2  on the line\n//            <0 for P2  right of the line\nfunction testLine(P0, P1, P2) {\n    const res = (P1.x - P0.x) * (P2.y - P0.y) - (P2.x - P0.x) * (P1.y - P0.y);\n    if (Math.abs(res) < util_1.EPSILON) {\n        return 0;\n    }\n    return Math.sign(res);\n}\nvar Position;\n(function (Position) {\n    Position[Position[\"INSIDE\"] = 1] = \"INSIDE\";\n    Position[Position[\"OUTSIDE\"] = -1] = \"OUTSIDE\";\n    Position[Position[\"BOUNDARY\"] = 0] = \"BOUNDARY\";\n})(Position = exports.Position || (exports.Position = {}));\n// Dan Sunday's winding number algorithm\nfunction wn_poly(P, V) {\n    let wn = 0; // the  winding number counter\n    const n = V.length - 1;\n    // loop through all edges of the polygon\n    for (let i = 0; i < n; i++) { // edge from V[i] to  V[i+1]\n        if (V[i].y <= P.y) { // start y <= P.y\n            if (V[i + 1].y > P.y) { // an upward crossing\n                const t = testLine(V[i], V[i + 1], P);\n                if (t === 0) {\n                    return Position.BOUNDARY;\n                }\n                if (t > 0) { // P left of  edge\n                    ++wn; // have a valid up intersect\n                }\n            }\n        }\n        else { // start y > P.y (no test needed)\n            if (V[i + 1].y <= P.y) { // a downward crossing\n                const t = testLine(V[i], V[i + 1], P);\n                if (t === 0) {\n                    return Position.BOUNDARY;\n                }\n                if (t < 0) { // P right of  edge\n                    --wn; // have a valid down intersect\n                }\n            }\n        }\n    }\n    return wn === 0 ? Position.OUTSIDE : Position.INSIDE;\n}\nexports.wn_poly = wn_poly;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.contourPass = void 0;\nconst LmtTable_1 = require(\"./LmtTable\");\nconst util_1 = require(\"./util\");\nfunction boundList(lmtTable, y) {\n    if (lmtTable.top === null) {\n        lmtTable.top = new LmtTable_1.LmtNode(y);\n        return lmtTable.top;\n    }\n    let prev = null;\n    let node = lmtTable.top;\n    while (true) {\n        if (y > node.y) {\n            /* Head further up the LMT */\n            if (node.next === null) {\n                node.next = new LmtTable_1.LmtNode(y);\n                return node.next;\n            }\n            else {\n                [prev, node] = [node, node.next];\n            }\n        }\n        else {\n            if (y < node.y) {\n                /* Insert a new LMT node before the current node */\n                node = new LmtTable_1.LmtNode(y, node);\n                if (prev === null) {\n                    lmtTable.top = node;\n                }\n                else {\n                    prev.next = node;\n                }\n            }\n            /* Use this existing LMT node */\n            return node;\n        }\n    }\n}\nfunction insertBound(lmtNode, e) {\n    if (lmtNode.firstBound === null) {\n        /* Link node e to the tail of the list */\n        lmtNode.firstBound = e;\n        return;\n    }\n    let prevBound = null;\n    let currentBound = lmtNode.firstBound;\n    while (true) {\n        /* Do primary sort on the x field and secondary sort on the dx field. */\n        if (e.bot.x < currentBound.bot.x || (e.bot.x === currentBound.bot.x && e.dx < currentBound.dx)) {\n            /* Insert a new node mid-list */\n            if (prevBound === null) {\n                lmtNode.firstBound = e;\n            }\n            else {\n                prevBound.nextBound = e;\n            }\n            e.nextBound = currentBound;\n            return;\n        }\n        /* Head further down the list */\n        if (currentBound.nextBound === null) {\n            currentBound.nextBound = e;\n            return;\n        }\n        else {\n            prevBound = currentBound;\n            currentBound = currentBound.nextBound;\n        }\n    }\n}\nfunction contourPass(edgeTable, lmtTable, vertexCount, eIndex, type, op, fwd) {\n    const next = fwd ? util_1.NEXT_INDEX : util_1.PREV_INDEX;\n    for (let min = 0; min < vertexCount; min++) {\n        /* If a forward local minimum... */\n        if (fwd ? edgeTable.FWD_MIN(min) : edgeTable.REV_MIN(min)) {\n            /* Search for the next local maximum... */\n            let edgeCount = 1;\n            let max = next(min, vertexCount);\n            while (fwd ? edgeTable.NOT_FMAX(max) : edgeTable.NOT_RMAX(max)) {\n                edgeCount++;\n                max = next(max, vertexCount);\n            }\n            /* Build the next edge list */\n            let v = min;\n            const e = edgeTable.getNode(eIndex);\n            e.bstate.below = util_1.BundleState.UNBUNDLED;\n            e.bundle.below[util_1.CLIP] = 0;\n            e.bundle.below[util_1.SUBJ] = 0;\n            for (let i = 0; i < edgeCount; i++) {\n                const ei = edgeTable.getNode(eIndex + i);\n                let ev = edgeTable.getNode(v);\n                ei.xb = ev.vertex.x;\n                ei.bot.x = ev.vertex.x;\n                ei.bot.y = ev.vertex.y;\n                v = next(v, vertexCount);\n                ev = edgeTable.getNode(v);\n                ei.top.x = ev.vertex.x;\n                ei.top.y = ev.vertex.y;\n                ei.dx = (ev.vertex.x - ei.bot.x) / (ei.top.y - ei.bot.y);\n                ei.type = type;\n                ei.outp.above = null;\n                ei.outp.below = null;\n                ei.next = null;\n                ei.prev = null;\n                ei.succ = ((edgeCount > 1) && (i < (edgeCount - 1))) ? edgeTable.getNode(eIndex + i + 1) : null;\n                ei.pred = ((edgeCount > 1) && (i > 0)) ? edgeTable.getNode(eIndex + i - 1) : null;\n                ei.nextBound = null;\n                ei.bside.clip = (op === util_1.OperationType.DIF) ? util_1.RIGHT : util_1.LEFT;\n                ei.bside.subj = util_1.LEFT;\n            }\n            insertBound(boundList(lmtTable, edgeTable.getNode(min).vertex.y), e);\n            eIndex += edgeCount;\n        }\n    }\n    return eIndex;\n}\nexports.contourPass = contourPass;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EdgeNode = void 0;\nclass EdgeNode {\n    constructor(x, y) {\n        this.bot = { x: NaN, y: NaN }; /* Edge lower (x, y) coordinate      */\n        this.top = { x: NaN, y: NaN }; /* Edge upper (x, y) coordinate      */\n        this.xb = NaN; /* Scanbeam bottom x coordinate      */\n        this.xt = NaN; /* Scanbeam top x coordinate         */\n        this.dx = NaN; /* Change in x for a unit y increase */\n        this.type = 0; /* Clip / subject edge flag          */\n        this.prev = null; /* Previous edge in the AET          */\n        this.next = null; /* Next edge in the AET              */\n        this.pred = null; /* Edge connected at the lower end   */\n        this.succ = null; /* Edge connected at the upper end   */\n        this.nextBound = null; /* Pointer to next bound in LMT      */\n        this.vertex = { x, y };\n        this.bside = { clip: 0, subj: 0 };\n        this.bundle = { above: [0, 0], below: [0, 0] };\n        this.bstate = { above: null, below: null };\n        this.outp = { above: null, below: null };\n    }\n}\nexports.EdgeNode = EdgeNode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.EdgeTable = void 0;\nconst EdgeNode_1 = require(\"./EdgeNode\");\nconst util_1 = require(\"./util\");\nclass EdgeTable {\n    constructor() {\n        this.nodeList = [];\n    }\n    addNode(x, y) {\n        this.nodeList.push(new EdgeNode_1.EdgeNode(x, y));\n    }\n    getNode(index) {\n        return this.nodeList[index];\n    }\n    FWD_MIN(i) {\n        const nodeList = this.nodeList;\n        const prev = nodeList[util_1.PREV_INDEX(i, nodeList.length)];\n        const next = nodeList[util_1.NEXT_INDEX(i, nodeList.length)];\n        const ith = nodeList[i];\n        return ((prev.vertex.y >= ith.vertex.y) &&\n            (next.vertex.y > ith.vertex.y));\n    }\n    NOT_FMAX(i) {\n        const nodeList = this.nodeList;\n        const next = nodeList[util_1.NEXT_INDEX(i, nodeList.length)];\n        const ith = nodeList[i];\n        return next.vertex.y > ith.vertex.y;\n    }\n    REV_MIN(i) {\n        const nodeList = this.nodeList;\n        const prev = nodeList[util_1.PREV_INDEX(i, nodeList.length)];\n        const next = nodeList[util_1.NEXT_INDEX(i, nodeList.length)];\n        const ith = nodeList[i];\n        return ((prev.vertex.y > ith.vertex.y) && (next.vertex.y >= ith.vertex.y));\n    }\n    NOT_RMAX(i) {\n        const nodeList = this.nodeList;\n        const prev = nodeList[util_1.PREV_INDEX(i, nodeList.length)];\n        const ith = nodeList[i];\n        return prev.vertex.y > ith.vertex.y;\n    }\n}\nexports.EdgeTable = EdgeTable;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OPTIMAL = void 0;\nconst util_1 = require(\"./util\");\nfunction OPTIMAL(p, i) {\n    const { y: yi } = p.get(i);\n    const numPoints = p.getNumPoints();\n    return (p.get(util_1.PREV_INDEX(i, numPoints)).y !== yi) ||\n        (p.get(util_1.NEXT_INDEX(i, numPoints)).y !== yi);\n}\nexports.OPTIMAL = OPTIMAL;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildLmt = exports.LmtTable = exports.LmtNode = void 0;\nconst CountorPass_1 = require(\"./CountorPass\");\nconst EdgeTable_1 = require(\"./EdgeTable\");\nconst IPolygon_1 = require(\"./IPolygon\");\nconst util_1 = require(\"./util\");\nclass LmtNode {\n    constructor(y, /* Y coordinate at local minimum     */ next = null) {\n        this.y = y;\n        this.next = next;\n        this.firstBound = null; /* Pointer to bound list             */\n    }\n}\nexports.LmtNode = LmtNode;\nclass LmtTable {\n    constructor() {\n        this.top = null;\n    }\n}\nexports.LmtTable = LmtTable;\nfunction buildLmt(lmtTable, sbte, p, type, // poly type SUBJ/CLIP\nop) {\n    /* Create the entire input polygon edge table in one go */\n    for (const ip of p.getInnerPolies()) {\n        if (!ip[util_1.isContributing](0)) {\n            /* Ignore the non-contributing contour */\n            ip[util_1.setContributing](0, true);\n        }\n        else {\n            /* Perform contour optimisation */\n            let vertexCount = 0;\n            const edgeTable = new EdgeTable_1.EdgeTable();\n            const pointLen = ip.getNumPoints();\n            for (let i = 0; i < pointLen; i++) {\n                if (IPolygon_1.OPTIMAL(ip, i)) {\n                    const { x, y } = ip.get(i);\n                    edgeTable.addNode(x, y);\n                    /* Record vertex in the scanbeam table */\n                    sbte.addToSBTree(y);\n                    vertexCount++;\n                }\n            }\n            /* Do the contour forward pass */\n            const eIndex = CountorPass_1.contourPass(edgeTable, lmtTable, vertexCount, 0, type, op, true);\n            /* Do the contour reverse pass */\n            CountorPass_1.contourPass(edgeTable, lmtTable, vertexCount, eIndex, type, op, false);\n        }\n    }\n}\nexports.buildLmt = buildLmt;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TopPolygonNode = exports.PolygonNode = void 0;\nconst Conditioning_1 = require(\"./Conditioning\");\nconst util_1 = require(\"./util\");\nclass PolygonNode {\n    constructor(next, x, y) {\n        this.active = true; /* Active flag / vertex count        */\n        this.hole = false; /* Hole / external contour flag      */\n        const vn = new util_1.VertexNode(x, y);\n        this.left = vn;\n        this.right = vn;\n        this.next = next;\n        this.proxy = this;\n    }\n    addRight(x, y) {\n        const nv = new util_1.VertexNode(x, y);\n        /* Add vertex nv to the right end of the polygon's vertex list */\n        this.proxy.right.next = nv;\n        this.proxy.right = nv;\n    }\n    addLeft(x, y) {\n        /* Add vertex nv to the left end of the polygon's vertex list */\n        this.proxy.left = new util_1.VertexNode(x, y, this.proxy.left);\n    }\n}\nexports.PolygonNode = PolygonNode;\nclass TopPolygonNode {\n    constructor(Simple, Compound) {\n        this.Simple = Simple;\n        this.Compound = Compound;\n        this.top = null;\n    }\n    addLocalMin(x, y) {\n        const n = new PolygonNode(this.top, x, y);\n        this.top = n;\n        return n;\n    }\n    mergeLeft(p, q) {\n        /* Label contour as a hole */\n        q.proxy.hole = true;\n        if (p.proxy !== q.proxy) {\n            /* Assign p's vertex list to the left end of q's list */\n            p.proxy.right.next = q.proxy.left;\n            q.proxy.left = p.proxy.left;\n            /* Redirect any p.proxy references to q.proxy */\n            const target = p.proxy;\n            for (let node = this.top; node !== null; node = node.next) {\n                if (node.proxy === target) {\n                    node.active = false;\n                    node.proxy = q.proxy;\n                }\n            }\n        }\n    }\n    mergeRight(p, q) {\n        /* Label contour as external */\n        q.proxy.hole = false;\n        if (p.proxy !== q.proxy) {\n            /* Assign p's vertex list to the right end of q's list */\n            q.proxy.right.next = p.proxy.left;\n            q.proxy.right = p.proxy.right;\n            /* Redirect any p->proxy references to q->proxy */\n            const target = p.proxy;\n            for (let node = this.top; node !== null; node = node.next) {\n                if (node.proxy === target) {\n                    node.active = false;\n                    node.proxy = q.proxy;\n                }\n            }\n        }\n    }\n    getContours() {\n        const contours = [];\n        outer: for (let polygon = this.top; polygon !== null; polygon = polygon.next) {\n            if (!polygon.active) {\n                continue;\n            }\n            /* Count the vertices in the current contour */\n            let nv = 0;\n            for (let vtx = polygon.proxy.left; vtx !== null; vtx = vtx.next) {\n                if ((++nv) > 2) {\n                    contours.push(polygon);\n                    continue outer;\n                }\n            }\n            polygon.active = false;\n        }\n        return contours;\n    }\n    getResult() {\n        const contours = this.getContours();\n        if (contours.length === 0) {\n            return new this.Simple([], false);\n        }\n        const innerPolies = contours.flatMap((polyNode) => {\n            const polys = [];\n            const isHole = polyNode.proxy.hole;\n            let vertices = [];\n            for (let vtx = polyNode.proxy.left; vtx !== null; vtx = vtx.next) {\n                //if (vtx.next && vert_eql(vtx, vtx.next)) { continue; }\n                for (let i = vertices.length - 1; i >= 0; i--) {\n                    if (util_1.vert_eql(vertices[i], vtx)) {\n                        polys.push(new this.Simple(Conditioning_1.rotateBottomLeft(vertices.slice(i)), isHole));\n                        vertices.length = i;\n                    }\n                }\n                vertices.push({ x: vtx.x, y: vtx.y });\n            }\n            polys.push(new this.Simple(Conditioning_1.rotateBottomLeft(vertices), isHole));\n            return polys;\n        });\n        return (innerPolies.length === 1) ? innerPolies[0] : new this.Compound(innerPolies);\n    }\n}\nexports.TopPolygonNode = TopPolygonNode;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ScanBeamTreeEntries = void 0;\nclass ScanBeamTree {\n    constructor(y) {\n        this.y = y;\n        this.less = null; /* Pointer to nodes with lower y     */\n        this.more = null; /* Pointer to nodes with higher y    */\n    } /* Scanbeam node y value             */\n}\nclass ScanBeamTreeEntries {\n    constructor() {\n        this.sbtEntries = 0;\n        this.sbTree = null;\n    }\n    addToSBTree(y) {\n        if (this.sbTree === null) {\n            /* Add a new tree node here */\n            this.sbTree = new ScanBeamTree(y);\n            this.sbtEntries++;\n            return;\n        }\n        let treeNode = this.sbTree;\n        while (treeNode.y !== y) {\n            const dir = treeNode.y > y ? \"less\" : \"more\";\n            const child = treeNode[dir];\n            if (child === null) {\n                treeNode[dir] = new ScanBeamTree(y);\n                this.sbtEntries++;\n                return;\n            }\n            else {\n                treeNode = child;\n            }\n        }\n    }\n    buildSBT() {\n        if (this.sbTree === null)\n            return [];\n        const sbt = [];\n        (function inner(entries, table, sbtNode) {\n            if (sbtNode.less !== null) {\n                entries = inner(entries, table, sbtNode.less);\n            }\n            table[entries] = sbtNode.y;\n            entries++;\n            if (sbtNode.more !== null) {\n                entries = inner(entries, table, sbtNode.more);\n            }\n            return entries;\n        })(0, sbt, this.sbTree);\n        return sbt;\n    }\n}\nexports.ScanBeamTreeEntries = ScanBeamTreeEntries;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.addSTEdge = exports.ItNodeTable = exports.StNode = void 0;\nconst util_1 = require(\"./util\");\nclass StNode {\n    constructor(edge, prev) {\n        this.edge = edge;\n        this.xb = edge.xb;\n        this.xt = edge.xt;\n        this.dx = edge.dx;\n        this.prev = prev;\n    }\n}\nexports.StNode = StNode;\nclass ItNode {\n    constructor(edge0, edge1, x, y, next) {\n        this.ie = [edge0, edge1];\n        this.point = { x, y };\n        this.next = next;\n    }\n}\nclass ItNodeTable {\n    constructor() {\n        this.top = null;\n    }\n    buildIntersectionTable(aet, dy) {\n        let st = null;\n        /* Process each AET edge */\n        for (let edge = aet.top; edge !== null; edge = edge.next) {\n            if ((edge.bstate.above === util_1.BundleState.BUNDLE_HEAD) ||\n                (edge.bundle.above[util_1.CLIP] !== 0) ||\n                (edge.bundle.above[util_1.SUBJ] !== 0)) {\n                st = addSTEdge(st, this, edge, dy);\n            }\n        }\n    }\n}\nexports.ItNodeTable = ItNodeTable;\nfunction addIntersection(itNode, edge0, edge1, x, y) {\n    if (itNode === null || itNode.point.y > y) {\n        /* Append a new node to the tail (itNode === null) or mid-list */\n        return new ItNode(edge0, edge1, x, y, itNode);\n    }\n    /* Head further down the list */\n    itNode.next = addIntersection(itNode.next, edge0, edge1, x, y);\n    return itNode;\n}\nfunction addSTEdge(st, it, edge, dy) {\n    if (st === null) {\n        /* Append edge onto the tail end of the ST */\n        return new StNode(edge, null);\n    }\n    const den = (st.xt - st.xb) - (edge.xt - edge.xb);\n    /* If new edge and ST edge don't cross */\n    if ((edge.xt >= st.xt) || (edge.dx === st.dx) || (Math.abs(den) <= util_1.EPSILON)) {\n        /* No intersection - insert edge here (before the ST edge) */\n        return new StNode(edge, st);\n    }\n    /* Compute intersection between new edge and ST edge */\n    const r = (edge.xb - st.xb) / den;\n    const x = st.xb + r * (st.xt - st.xb);\n    const y = r * dy;\n    /* Insert the edge pointers and the intersection point in the IT */\n    it.top = addIntersection(it.top, st.edge, edge, x, y);\n    /* Head further into the ST */\n    st.prev = addSTEdge(st.prev, it, edge, dy);\n    return st;\n}\nexports.addSTEdge = addSTEdge;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.convexHull = exports.polygonHull = void 0;\nfunction ccw(a, b, c) {\n    return (b.y - a.y) * (c.x - a.x) - (b.x - a.x) * (c.y - a.y);\n}\n// Graham scan. Assumes a simple polygon.\nfunction polygonHull(points) {\n    const n = points.length;\n    // There can never be fewer than 4 vertices.\n    // Assume the first point is bottom-left-most\n    const p0 = points[0];\n    let top = 1;\n    for (let i = 2; i < n; i++) {\n        // Duplicate points are pre-filtered\n        // if (points[top].x === points[i].x && points[top].y === points[i].y) { continue; }\n        points[++top] = points[i];\n        while (top >= 2 && ccw(points[top - 2], points[top - 1], points[top]) >= 0) {\n            points[top - 1] = points[top]; // delete internal point\n            top--;\n        }\n    }\n    // Fix up the join between the tail and start\n    while (ccw(points[top - 1], points[top], p0) >= 0) {\n        top--;\n    }\n    points.length = top + 1;\n    return points;\n}\nexports.polygonHull = polygonHull;\nfunction convexHull(points) {\n    // Assume the first point is bottom-left-most and sort by angle\n    const p0 = points[0];\n    points.sort((a, b) => ccw(p0, a, b) || a.x - b.x);\n    return polygonHull(points);\n}\nexports.convexHull = convexHull;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.polygonArea = exports.Rectangle = exports.HState = exports.getVertexType = exports.VertexType = exports.NEXT_INDEX = exports.PREV_INDEX = exports.EQ = exports.OperationType = exports.setContributing = exports.isContributing = exports.SUBJ = exports.CLIP = exports.RIGHT = exports.LEFT = exports.EPSILON = exports.BundleState = exports.VertexNode = exports.vert_eql = void 0;\nfunction vert_eql(a, b) {\n    return a.x === b.x && a.y === b.y;\n}\nexports.vert_eql = vert_eql;\nclass VertexNode {\n    constructor(x, y, next = null) {\n        this.x = x;\n        this.y = y;\n        this.next = next;\n    }\n}\nexports.VertexNode = VertexNode;\nvar BundleState;\n(function (BundleState) {\n    BundleState[BundleState[\"UNBUNDLED\"] = 0] = \"UNBUNDLED\";\n    BundleState[BundleState[\"BUNDLE_HEAD\"] = 1] = \"BUNDLE_HEAD\";\n    BundleState[BundleState[\"BUNDLE_TAIL\"] = 2] = \"BUNDLE_TAIL\";\n})(BundleState = exports.BundleState || (exports.BundleState = {}));\nexports.EPSILON = 2.2204460492503131e-16;\nexports.LEFT = 0;\nexports.RIGHT = 1;\nexports.CLIP = 0;\nexports.SUBJ = 1;\nexports.isContributing = Symbol();\nexports.setContributing = Symbol();\nvar OperationType;\n(function (OperationType) {\n    OperationType[OperationType[\"DIF\"] = 0] = \"DIF\";\n    OperationType[OperationType[\"INT\"] = 1] = \"INT\";\n    OperationType[OperationType[\"XOR\"] = 2] = \"XOR\";\n    OperationType[OperationType[\"ADD\"] = 3] = \"ADD\";\n})(OperationType = exports.OperationType || (exports.OperationType = {}));\nfunction EQ(a, b) {\n    return (Math.abs(a - b) <= exports.EPSILON);\n}\nexports.EQ = EQ;\nfunction PREV_INDEX(i, n) {\n    return ((i - 1 + n) % n);\n}\nexports.PREV_INDEX = PREV_INDEX;\nfunction NEXT_INDEX(i, n) {\n    return ((i + 1) % n);\n}\nexports.NEXT_INDEX = NEXT_INDEX;\nvar VertexType;\n(function (VertexType) {\n    VertexType[VertexType[\"NUL\"] = 0] = \"NUL\";\n    VertexType[VertexType[\"EMX\"] = 1] = \"EMX\";\n    VertexType[VertexType[\"ELI\"] = 2] = \"ELI\";\n    VertexType[VertexType[\"TED\"] = 3] = \"TED\";\n    VertexType[VertexType[\"ERI\"] = 4] = \"ERI\";\n    VertexType[VertexType[\"RED\"] = 5] = \"RED\";\n    VertexType[VertexType[\"IMM\"] = 6] = \"IMM\";\n    VertexType[VertexType[\"IMN\"] = 7] = \"IMN\";\n    VertexType[VertexType[\"EMN\"] = 8] = \"EMN\";\n    VertexType[VertexType[\"EMM\"] = 9] = \"EMM\";\n    VertexType[VertexType[\"LED\"] = 10] = \"LED\";\n    VertexType[VertexType[\"ILI\"] = 11] = \"ILI\";\n    VertexType[VertexType[\"BED\"] = 12] = \"BED\";\n    VertexType[VertexType[\"IRI\"] = 13] = \"IRI\";\n    VertexType[VertexType[\"IMX\"] = 14] = \"IMX\";\n    VertexType[VertexType[\"FUL\"] = 15] = \"FUL\";\n})(VertexType = exports.VertexType || (exports.VertexType = {}));\nfunction getVertexType(tr, tl, br, bl) {\n    return tr + (tl << 1) + (br << 2) + (bl << 3);\n}\nexports.getVertexType = getVertexType;\nvar HState;\n(function (HState) {\n    HState.NH = 0; /* No horizontal edge                */\n    HState.BH = 1; /* Bottom horizontal edge            */\n    HState.TH = 2; /* Top horizontal edge               */\n    /* Horizontal edge state transitions within scanbeam boundary */\n    HState.nextState = [\n        /*        ABOVE     BELOW     CROSS */\n        /*        L   R     L   R     L   R */\n        /* NH */ [HState.BH, HState.TH, HState.TH, HState.BH, HState.NH, HState.NH],\n        /* BH */ [HState.NH, HState.NH, HState.NH, HState.NH, HState.TH, HState.TH],\n        /* TH */ [HState.NH, HState.NH, HState.NH, HState.NH, HState.BH, HState.BH],\n    ];\n})(HState = exports.HState || (exports.HState = {}));\nclass Rectangle {\n    constructor(minx, miny, maxx, maxy) {\n        this.minx = minx;\n        this.miny = miny;\n        this.maxx = maxx;\n        this.maxy = maxy;\n    }\n}\nexports.Rectangle = Rectangle;\nfunction polygonArea(points) {\n    const n = points.length;\n    let a = 0;\n    let { x: jx, y: jy } = points[n - 1];\n    for (let i = 0; i < n; i++) {\n        const { x: ix, y: iy } = points[i];\n        a += (jx + ix) * (jy - iy);\n        jx = ix;\n        jy = iy;\n    }\n    return a / 2;\n}\nexports.polygonArea = polygonArea;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Polygon = void 0;\nconst Clip_1 = require(\"./Clip\");\nconst Conditioning_1 = require(\"./Conditioning\");\nconst Contains_1 = require(\"./Contains\");\nconst hull_1 = require(\"./hull\");\nconst util_1 = require(\"./util\");\nclass Polygon {\n    toJSON() {\n        return this.toVertices();\n    }\n    static n_ary(op, ...polys) {\n        return polys.reduce((acc, p) => Clip_1.clip(op, acc, p, SimplePolygon, MultiPolygon));\n    }\n    static intersection(...p) {\n        return Polygon.n_ary(util_1.OperationType.INT, ...p);\n    }\n    intersection(...p) {\n        return Polygon.intersection(this, ...p);\n    }\n    static union(...p) {\n        return Polygon.n_ary(util_1.OperationType.ADD, ...p);\n    }\n    union(...p) {\n        return Polygon.union(this, ...p);\n    }\n    static xor(...p) {\n        return Polygon.n_ary(util_1.OperationType.XOR, ...p);\n    }\n    xor(...p) {\n        return Polygon.xor(this, ...p);\n    }\n    static difference(first, ...p) {\n        switch (p.length) {\n            case 0: return first;\n            case 1: return Clip_1.clip(util_1.OperationType.DIF, first, p[0], SimplePolygon, MultiPolygon);\n            default: {\n                const clipper = p.reduce((acc, n) => Clip_1.clip(util_1.OperationType.ADD, acc, n, SimplePolygon, MultiPolygon));\n                return Clip_1.clip(util_1.OperationType.DIF, first, clipper, SimplePolygon, MultiPolygon);\n            }\n        }\n    }\n    difference(...p) {\n        return Polygon.difference(this, ...p);\n    }\n    static fromPoints(points) {\n        points = points.map((p) => Array.isArray(p) ? { x: p[0] || 0, y: p[1] || 0 } : p);\n        points = Conditioning_1.rotateBottomLeft(points);\n        const a = Conditioning_1.forceWinding(1, points);\n        const p = new SimplePolygon(points, false);\n        p.area = a;\n        return p;\n    }\n    static holeFromPoints(points) {\n        points = points.map((p) => Array.isArray(p) ? { x: p[0] || 0, y: p[1] || 0 } : p);\n        points = Conditioning_1.rotateBottomLeft(points);\n        const a = Conditioning_1.forceWinding(-1, points);\n        const p = new SimplePolygon(points, true);\n        p.area = a;\n        return p;\n    }\n    static fromVertices({ bounds, holes }) {\n        return Polygon.n_ary(util_1.OperationType.ADD, ...bounds.map(Polygon.fromPoints), ...holes.map(Polygon.holeFromPoints));\n    }\n}\nexports.Polygon = Polygon;\n// A simple polygon, with only one inner polygon--itself.\nclass SimplePolygon extends Polygon {\n    constructor(pointList, isHole) {\n        super();\n        this.pointList = pointList;\n        this.isHole = isHole;\n        this.hull = null;\n        this.area = NaN;\n        this.json = null;\n        /** Flag used by the Clip algorithm */\n        this.contributes = true;\n        this._bounds = null;\n    }\n    equals(that) {\n        if (that === this) {\n            return true;\n        }\n        if (!(that instanceof SimplePolygon) || this.isHole !== that.isHole) {\n            return false;\n        }\n        const { pointList: v } = this;\n        const { pointList: u } = that;\n        const n = v.length;\n        if (n !== u.length) {\n            return false;\n        }\n        return v.every(({ x: vx, y: vy }, i) => {\n            const { x: ux, y: uy } = u[i];\n            return Math.abs(vx - ux) < util_1.EPSILON && Math.abs(vy - uy) < util_1.EPSILON;\n        });\n    }\n    get isEmpty() {\n        return this.pointList.length === 0;\n    }\n    get bounds() {\n        if (this._bounds === null) {\n            let xmin = Number.MAX_VALUE;\n            let ymin = Number.MAX_VALUE;\n            let xmax = -Number.MAX_VALUE;\n            let ymax = -Number.MAX_VALUE;\n            for (const { x, y } of this.pointList) {\n                if (x < xmin) {\n                    xmin = x;\n                }\n                if (x > xmax) {\n                    xmax = x;\n                }\n                if (y < ymin) {\n                    ymin = y;\n                }\n                if (y > ymax) {\n                    ymax = y;\n                }\n            }\n            this._bounds = new util_1.Rectangle(xmin, ymin, xmax, ymax);\n        }\n        return this._bounds;\n    }\n    getInnerPolies() {\n        return [this];\n    }\n    getNumPoints() {\n        return this.pointList.length;\n    }\n    get(index) {\n        return this.pointList[index];\n    }\n    iterVertices() {\n        return this.pointList[Symbol.iterator]();\n    }\n    getArea() {\n        if (isNaN(this.area)) {\n            this.area = util_1.polygonArea(this.pointList);\n        }\n        return this.area;\n    }\n    contains(p) {\n        if (p instanceof Polygon) {\n            let inside = 0;\n            let outside = 0;\n            for (const v of p.iterVertices()) {\n                const pos = Contains_1.wn_poly(v, this.pointList);\n                if (pos === Contains_1.Position.INSIDE) {\n                    inside++;\n                }\n                else if (pos === Contains_1.Position.OUTSIDE) {\n                    outside++;\n                }\n            }\n            if (inside > 0 && outside === 0) {\n                return this.isHole ? Contains_1.Position.OUTSIDE : Contains_1.Position.INSIDE;\n            }\n            if (outside > 0 && inside === 0) {\n                return this.isHole ? Contains_1.Position.INSIDE : Contains_1.Position.OUTSIDE;\n            }\n            return Contains_1.Position.BOUNDARY;\n        }\n        if (p instanceof Array) {\n            p = { x: p[0], y: p[1] };\n        }\n        // TODO: Test with holes\n        return Contains_1.wn_poly(p, this.pointList);\n    }\n    explode() {\n        return [this];\n    }\n    [util_1.isContributing](polyIndex) {\n        if (polyIndex !== 0) {\n            throw new Error(\"SimplePolygon only has one poly\");\n        }\n        return this.contributes;\n    }\n    [util_1.setContributing](polyIndex, contributes) {\n        if (polyIndex !== 0) {\n            throw new Error(\"SimplePolygon only has one poly\");\n        }\n        this.contributes = contributes;\n    }\n    toVertices() {\n        if (!this.json) {\n            this.json = this.isHole ?\n                { bounds: [], holes: [this.pointList] } :\n                { bounds: [this.pointList], holes: [] };\n        }\n        return this.json;\n    }\n    getHull() {\n        if (this.hull) {\n            return this.hull;\n        }\n        this.hull = Conditioning_1.isConvex(this.pointList) ? this : new SimplePolygon(hull_1.polygonHull([...this.iterVertices()]), false);\n        return this.hull;\n    }\n}\n// MultiPolygon provides support for complex (with multiple disjoint cycles) and simple polygons and holes.\nclass MultiPolygon extends Polygon {\n    constructor(polyList) {\n        super();\n        this.polyList = polyList;\n        this.hull = null;\n        this.area = NaN;\n        this.explosion = null;\n        this.json = null;\n        this._bounds = null;\n        this.polyList.sort((a, b) => {\n            const ap = a.get(0);\n            const bp = b.get(0);\n            const t = ap.y - bp.y;\n            return t === 0 ? ap.x - bp.x : t;\n        });\n        this.numPoints = polyList.reduce((a, n) => a + n.getNumPoints(), 0);\n    }\n    equals(that) {\n        return (that === this) || ((that instanceof MultiPolygon) &&\n            that.polyList.length === this.polyList.length &&\n            this.polyList.every((p, i) => p.equals(that.polyList[i])));\n    }\n    get isHole() {\n        return false;\n    }\n    get isEmpty() {\n        return this.polyList.length === 0;\n    }\n    get bounds() {\n        if (this._bounds === null) {\n            const { polyList } = this;\n            if (polyList.length === 0) {\n                this._bounds = new util_1.Rectangle(NaN, NaN, NaN, NaN);\n            }\n            else if (polyList.length === 1) {\n                this._bounds = this.polyList[0].bounds;\n            }\n            else {\n                let xmin = Number.MAX_VALUE;\n                let ymin = Number.MAX_VALUE;\n                let xmax = -Number.MAX_VALUE;\n                let ymax = -Number.MAX_VALUE;\n                for (const p of this.polyList) {\n                    const { maxx, maxy, minx, miny } = p.bounds;\n                    if (minx < xmin) {\n                        xmin = minx;\n                    }\n                    if (maxx > xmax) {\n                        xmax = maxx;\n                    }\n                    if (miny < ymin) {\n                        ymin = miny;\n                    }\n                    if (maxy > ymax) {\n                        ymax = maxy;\n                    }\n                }\n                this._bounds = new util_1.Rectangle(xmin, ymin, xmax, ymax);\n            }\n        }\n        return this._bounds;\n    }\n    getInnerPolies() {\n        return this.polyList;\n    }\n    getNumPoints() {\n        return this.numPoints;\n    }\n    get(index) {\n        for (const p of this.polyList) {\n            const n = p.getNumPoints();\n            if (index < n) {\n                return p.get(index);\n            }\n            index -= n;\n        }\n        throw new Error(\"Index out of bounds\");\n    }\n    *iterVertices() {\n        for (const p of this.polyList) {\n            yield* p.pointList;\n        }\n    }\n    getArea() {\n        if (isNaN(this.area)) {\n            this.area = this.polyList.reduce((a, n) => a + n.getArea(), 0);\n        }\n        return this.area;\n    }\n    contains(p) {\n        if (p instanceof Polygon) {\n            let inside = 0;\n            let outside = 0;\n            for (const v of p.iterVertices()) {\n                const contained = this.polyList.some(ipoly => ipoly.contains(v) !== Contains_1.Position.OUTSIDE);\n                if (contained) {\n                    inside++;\n                }\n                else {\n                    outside++;\n                }\n            }\n            if (inside > 0 && outside === 0) {\n                return Contains_1.Position.INSIDE;\n            }\n            if (outside > 0 && inside === 0) {\n                return Contains_1.Position.OUTSIDE;\n            }\n            return Contains_1.Position.BOUNDARY;\n        }\n        if (p instanceof Array) {\n            p = { x: p[0], y: p[1] };\n        }\n        let inside = 0;\n        let boundary = 0;\n        for (const ipoly of this.polyList) {\n            const pos = ipoly.contains(p);\n            if (pos === Contains_1.Position.INSIDE) {\n                inside++;\n            }\n            else if (pos === Contains_1.Position.BOUNDARY) {\n                boundary++;\n            }\n        }\n        if (inside > 0) {\n            return Contains_1.Position.INSIDE;\n        }\n        if (boundary > 0) {\n            return Contains_1.Position.BOUNDARY;\n        }\n        return Contains_1.Position.OUTSIDE;\n    }\n    explode() {\n        if (this.explosion) {\n            return this.explosion;\n        }\n        const bounds = [];\n        const holes = new Set();\n        for (const poly of this.polyList) {\n            if (poly.isHole) {\n                holes.add(poly);\n            }\n            else {\n                bounds.push(poly);\n            }\n        }\n        if (bounds.length === 1) {\n            this.explosion = [this];\n        }\n        else {\n            const result = [];\n            for (const b of bounds) {\n                const components = [b];\n                for (const h of holes) {\n                    if (Contains_1.wn_poly(h.get(0), b.pointList) === Contains_1.Position.INSIDE) {\n                        components.push(h);\n                        holes.delete(h);\n                    }\n                }\n                if (components.length === 1) {\n                    result.push(b);\n                }\n                else {\n                    result.push(new MultiPolygon(components));\n                }\n            }\n            this.explosion = result;\n        }\n        return this.explosion;\n    }\n    [util_1.isContributing](polyIndex) {\n        return this.polyList[polyIndex][util_1.isContributing](0);\n    }\n    [util_1.setContributing](polyIndex, contributes) {\n        this.polyList[polyIndex][util_1.setContributing](0, contributes);\n    }\n    toVertices() {\n        if (!this.json) {\n            const bounds = [];\n            const holes = [];\n            for (const poly of this.polyList) {\n                const { bounds: nb, holes: nh } = poly.toVertices();\n                bounds.push(...nb);\n                holes.push(...nh);\n            }\n            this.json = { bounds, holes };\n        }\n        return this.json;\n    }\n    getHull() {\n        if (this.hull) {\n            return this.hull;\n        }\n        const e = this.explode();\n        if (e[0] === this) {\n            this.hull = this.polyList[0].getHull();\n        }\n        else {\n            const candidates = [];\n            for (const p of this.polyList) {\n                if (p.isHole) {\n                    continue;\n                }\n                for (const v of p.getHull().iterVertices()) {\n                    candidates.push(v);\n                }\n            }\n            this.hull = new SimplePolygon(hull_1.convexHull(candidates), false);\n        }\n        return this.hull;\n    }\n}\n"],"names":[],"sourceRoot":""}